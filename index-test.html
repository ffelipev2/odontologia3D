<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Test de Modelos 3D - Estable</title>
  <style>
    body { margin: 0; overflow: hidden; background: #0b1020; color: #fff; font-family: system-ui, sans-serif; }
    .toolbar {
      position: fixed;
      top: 10px; left: 10px;
      background: rgba(10,15,30,0.9);
      display: flex; flex-wrap: wrap; align-items: center;
      gap: 8px; padding: 8px 14px;
      border-radius: 10px;
      z-index: 20; box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }
    .toolbar input {
      background: #111; color: #fff; border: 1px solid #333;
      border-radius: 6px; padding: 4px 6px; font-size: 13px;
      width: 60px; text-align: right;
    }
    .toolbar button {
      padding: 6px 10px; border: 0; border-radius: 8px;
      cursor: pointer; font-weight: 600;
      background: #1d4ed8; color: #fff; transition: 0.2s;
    }
    .toolbar button:hover { background: #2563eb; }
    #coordsBox {
      position: fixed; bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.7); color: #fff;
      padding: 8px 12px; font-family: monospace;
      font-size: 13px; border-radius: 8px;
      z-index: 15;
    }
    #exportBox {
      position: fixed; right: 10px; bottom: 10px;
      width: 360px; height: 220px; font-family: monospace;
      font-size: 12px; background: #111; color: #0f0;
      border: 1px solid #333; border-radius: 8px;
      padding: 10px; display: none; z-index: 25;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div class="toolbar">
    OBJ <input type="file" id="objFile" accept=".obj">
    MTL <input type="file" id="mtlFile" accept=".mtl">
    <button id="btnLoad">Cargar</button>
    <button id="btnReset">Recentrar cámara</button>
    <button id="btnExport">Exportar JSON</button>
    <br>
    Pos: X <input id="posX" type="number" step="0.1" value="0">
    Y <input id="posY" type="number" step="0.1" value="0">
    Z <input id="posZ" type="number" step="0.1" value="0">
    Rot: X <input id="rotX" type="number" step="1" value="0">
    Y <input id="rotY" type="number" step="1" value="0">
    Z <input id="rotZ" type="number" step="1" value="0">
  </div>

  <canvas id="c"></canvas>
  <div id="coordsBox"></div>
  <textarea id="exportBox" readonly></textarea>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

    let scene, camera, renderer, controls;
    let currentObject = null;
    let modelAxes = null;

    const coordsBox = document.getElementById('coordsBox');
    const exportBox = document.getElementById('exportBox');

    init();

    function init() {
      const canvas = document.getElementById('c');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1020);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 15);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 5);
      scene.add(hemi, dir);

      const worldAxes = new THREE.AxesHelper(5);
      scene.add(worldAxes);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;

      window.addEventListener('resize', onResize);
      animate();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      updateCoords();
    }

    document.getElementById('btnLoad').addEventListener('click', async () => {
      const objInput = document.getElementById('objFile');
      const mtlInput = document.getElementById('mtlFile');
      if (!objInput.files[0]) return alert('Selecciona un archivo OBJ primero.');

      // Limpiar modelo anterior
      cleanPreviousModel();

      const objURL = URL.createObjectURL(objInput.files[0]);
      const mtlURL = mtlInput.files[0] ? URL.createObjectURL(mtlInput.files[0]) : null;

      const manager = new THREE.LoadingManager();
      const objLoader = new OBJLoader(manager);
      const mtlLoader = new MTLLoader(manager);

      if (mtlURL) {
        mtlLoader.load(mtlURL, materials => {
          materials.preload();
          objLoader.setMaterials(materials);
          objLoader.load(objURL, obj => {
            addToScene(obj);
            URL.revokeObjectURL(objURL);
            URL.revokeObjectURL(mtlURL);
          });
        });
      } else {
        objLoader.load(objURL, obj => {
          addToScene(obj);
          URL.revokeObjectURL(objURL);
        });
      }
    });

    function cleanPreviousModel() {
      if (currentObject) {
        scene.remove(currentObject);
        currentObject.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        currentObject = null;
      }
      if (modelAxes) {
        scene.remove(modelAxes);
        modelAxes = null;
      }
      renderer.renderLists.dispose();
    }

    function addToScene(obj) {
      // Buscar objeto con malla visible
      let target = obj;
      obj.traverse(child => {
        if (child.isMesh && !target.isMesh) target = child;
      });

      // Centrar el modelo
      const box = new THREE.Box3().setFromObject(target);
      const center = new THREE.Vector3();
      box.getCenter(center);
      target.position.sub(center);

      scene.add(target);
      currentObject = target;

      // Ejes del modelo visibles siempre
      modelAxes = new THREE.AxesHelper(2);
      target.add(modelAxes);

      console.log('Modelo cargado:', target);
    }

    document.getElementById('btnReset').addEventListener('click', () => {
      camera.position.set(0, 5, 15);
      controls.target.set(0, 0, 0);
      controls.update();
    });

    ['posX','posY','posZ','rotX','rotY','rotZ'].forEach(id => {
      document.getElementById(id).addEventListener('input', () => {
        if (!currentObject) return;
        currentObject.position.set(
          parseFloat(document.getElementById('posX').value),
          parseFloat(document.getElementById('posY').value),
          parseFloat(document.getElementById('posZ').value)
        );
        currentObject.rotation.set(
          THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value)),
          THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value)),
          THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value))
        );
        renderer.render(scene, camera);
      });
    });

    function updateCoords() {
      const pos = currentObject ? currentObject.position : {x:0,y:0,z:0};
      const rot = currentObject ? currentObject.rotation : {x:0,y:0,z:0};
      coordsBox.innerHTML = `
        <b>Objeto</b><br>
        posX: ${pos.x.toFixed(2)} | posY: ${pos.y.toFixed(2)} | posZ: ${pos.z.toFixed(2)}<br>
        rotX: ${(THREE.MathUtils.radToDeg(rot.x)).toFixed(1)} | rotY: ${(THREE.MathUtils.radToDeg(rot.y)).toFixed(1)} | rotZ: ${(THREE.MathUtils.radToDeg(rot.z)).toFixed(1)}<br><br>
        <b>Cámara</b><br>
        camX: ${camera.position.x.toFixed(2)} | camY: ${camera.position.y.toFixed(2)} | camZ: ${camera.position.z.toFixed(2)}<br>
        targetX: ${controls.target.x.toFixed(2)} | targetY: ${controls.target.y.toFixed(2)} | targetZ: ${controls.target.z.toFixed(2)}
      `;
    }

    document.getElementById('btnExport').addEventListener('click', () => {
      if (!currentObject) return alert('Carga un modelo primero.');
      const data = {
        position: [
          parseFloat(currentObject.position.x.toFixed(2)),
          parseFloat(currentObject.position.y.toFixed(2)),
          parseFloat(currentObject.position.z.toFixed(2))
        ],
        rotation: [
          parseFloat(THREE.MathUtils.radToDeg(currentObject.rotation.x).toFixed(2)),
          parseFloat(THREE.MathUtils.radToDeg(currentObject.rotation.y).toFixed(2)),
          parseFloat(THREE.MathUtils.radToDeg(currentObject.rotation.z).toFixed(2))
        ],
        camera: [
          parseFloat(camera.position.x.toFixed(2)),
          parseFloat(camera.position.y.toFixed(2)),
          parseFloat(camera.position.z.toFixed(2))
        ],
        target: [
          parseFloat(controls.target.x.toFixed(2)),
          parseFloat(controls.target.y.toFixed(2)),
          parseFloat(controls.target.z.toFixed(2))
        ]
      };
      exportBox.value = JSON.stringify(data, null, 2);
      exportBox.style.display = 'block';
    });
  </script>
</body>
</html>
